[[registeringCallbackClosures]]
=== Registering Callback Closures

Alternatively, enable events with `grails.plugin.springsecurity.useSecurityEventListener = true` and register one or more callback closure(s) in `grails-app/conf/application.groovy` and let `SecurityEventListener` do the filtering.

Implement the event handlers that you need, for example:

[source,java]
----
grails.plugin.springsecurity.useSecurityEventListener = true

grails.plugin.springsecurity. onInteractiveAuthenticationSuccessEvent = { e, appCtx ->
   // handle InteractiveAuthenticationSuccessEvent
}

grails.plugin.springsecurity. onAbstractAuthenticationFailureEvent = { e, appCtx ->
   // handle AbstractAuthenticationFailureEvent
}

grails.plugin.springsecurity. onAuthenticationSuccessEvent = { e, appCtx ->
   // handle AuthenticationSuccessEvent
}

grails.plugin.springsecurity. onAuthenticationSwitchUserEvent = { e, appCtx ->
   // handle AuthenticationSwitchUserEvent
}

grails.plugin.springsecurity. onAuthorizationEvent = { e, appCtx ->
   // handle AuthorizationEvent
}
----

None of these closures are required; if none are configured, nothing will be called. Just implement the event handlers that you need.

[NOTE]
====
When a user authenticates, Spring Security initially fires an `AuthenticationSuccessEvent`. This event fires before the `Authentication` is registered in the `SecurityContextHolder`, which means that the `springSecurityService` methods that access the logged-in user will not work. Later in the processing a second event is fired, an `InteractiveAuthenticationSuccessEvent`, and when this happens the `SecurityContextHolder` will have the `Authentication`. Depending on your needs, you can implement a callback for either or both events.
====
